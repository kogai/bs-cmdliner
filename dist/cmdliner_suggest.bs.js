// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

function levenshtein_distance(s, t) {
  var minimum = function (a, b, c) {
    return Caml_obj.caml_min(a, Caml_obj.caml_min(b, c));
  };
  var m = s.length;
  var n = t.length;
  var d = $$Array.make_matrix(m + 1 | 0, n + 1 | 0, 0);
  for(var i = 0; i <= m; ++i){
    Caml_array.caml_array_set(Caml_array.caml_array_get(d, i), 0, i);
  }
  for(var j = 0; j <= n; ++j){
    Caml_array.caml_array_set(Caml_array.caml_array_get(d, 0), j, j);
  }
  for(var j$1 = 1; j$1 <= n; ++j$1){
    for(var i$1 = 1; i$1 <= m; ++i$1){
      if (Caml_string.get(s, i$1 - 1 | 0) === Caml_string.get(t, j$1 - 1 | 0)) {
        Caml_array.caml_array_set(Caml_array.caml_array_get(d, i$1), j$1, Caml_array.caml_array_get(Caml_array.caml_array_get(d, i$1 - 1 | 0), j$1 - 1 | 0));
      } else {
        Caml_array.caml_array_set(Caml_array.caml_array_get(d, i$1), j$1, minimum(Caml_array.caml_array_get(Caml_array.caml_array_get(d, i$1 - 1 | 0), j$1) + 1 | 0, Caml_array.caml_array_get(Caml_array.caml_array_get(d, i$1), j$1 - 1 | 0) + 1 | 0, Caml_array.caml_array_get(Caml_array.caml_array_get(d, i$1 - 1 | 0), j$1 - 1 | 0) + 1 | 0));
      }
    }
  }
  return Caml_array.caml_array_get(Caml_array.caml_array_get(d, m), n);
}

function value(s, candidates) {
  var add = function (param, name) {
    var acc = param[1];
    var min = param[0];
    var d = levenshtein_distance(s, name);
    if (d === min) {
      return /* tuple */[
              min,
              /* :: */[
                name,
                acc
              ]
            ];
    } else if (d < min) {
      return /* tuple */[
              d,
              /* :: */[
                name,
                /* [] */0
              ]
            ];
    } else {
      return /* tuple */[
              min,
              acc
            ];
    }
  };
  var match = List.fold_left(add, /* tuple */[
        Pervasives.max_int,
        /* [] */0
      ], candidates);
  if (match[0] < 3) {
    return match[1];
  } else {
    return /* [] */0;
  }
}

exports.value = value;
/* No side effect */
