// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_sys = require("bs-platform/lib/js/caml_sys.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Cmdliner_trie = require("./cmdliner_trie.bs.js");
var Caml_missing_polyfill = require("bs-platform/lib/js/caml_missing_polyfill.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var err_empty_list = "empty list";

function pp_white_str(spaces, ppf, s) {
  var left = [0];
  var right = [0];
  var len = s.length;
  var flush = function () {
    Format.pp_print_string(ppf, $$String.sub(s, left[0], right[0] - left[0] | 0));
    right[0] = right[0] + 1 | 0;
    left[0] = right[0];
    return /* () */0;
  };
  while(right[0] !== len) {
    if (Caml_string.get(s, right[0]) === /* "\n" */10) {
      flush(/* () */0);
      Format.pp_force_newline(ppf, /* () */0);
    } else if (spaces && Caml_string.get(s, right[0]) === /* " " */32) {
      flush(/* () */0);
      Format.pp_print_space(ppf, /* () */0);
    } else {
      right[0] = right[0] + 1 | 0;
    }
  };
  if (left[0] !== len) {
    return flush(/* () */0);
  } else {
    return 0;
  }
}

function pp_text(param, param$1) {
  return pp_white_str(/* true */1, param, param$1);
}

function pp_lines(param, param$1) {
  return pp_white_str(/* false */0, param, param$1);
}

function pp_tokens(spaces, ppf, s) {
  var is_space = function (param) {
    var switcher = param - 9 | 0;
    if (switcher > 4 || switcher < 0) {
      if (switcher !== 23) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    } else if (switcher === 3 || switcher === 2) {
      return /* false */0;
    } else {
      return /* true */1;
    }
  };
  var i_max = s.length - 1 | 0;
  var flush = function (start, stop) {
    return Format.pp_print_string(ppf, $$String.sub(s, start, (stop - start | 0) + 1 | 0));
  };
  var skip_white = function (_i) {
    while(true) {
      var i = _i;
      if (i > i_max) {
        return i;
      } else if (is_space(Caml_string.get(s, i))) {
        _i = i + 1 | 0;
        continue ;
        
      } else {
        return i;
      }
    };
  };
  var _start = 0;
  var _i = 0;
  while(true) {
    var i = _i;
    var start = _start;
    if (i > i_max) {
      return flush(start, i_max);
    } else if (is_space(Caml_string.get(s, i))) {
      var next_start = skip_white(i);
      flush(start, i - 1 | 0);
      if (spaces) {
        Format.pp_print_space(ppf, /* () */0);
      } else {
        Format.pp_print_char(ppf, /* " " */32);
      }
      if (next_start > i_max) {
        return /* () */0;
      } else {
        _i = next_start;
        _start = next_start;
        continue ;
        
      }
    } else {
      _i = i + 1 | 0;
      continue ;
      
    }
  };
}

function quote(s) {
  return Curry._1(Printf.sprintf(/* Format */[
                  /* Char_literal */Block.__(12, [
                      /* "`" */96,
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* "'" */39,
                              /* End_of_format */0
                            ])
                        ])
                    ]),
                  "`%s'"
                ]), s);
}

function alts_str($staropt$star, alts) {
  var quoted = $staropt$star ? $staropt$star[0] : /* true */1;
  var quote$1 = quoted ? quote : (function (s) {
        return s;
      });
  if (alts) {
    var match = alts[1];
    var a = alts[0];
    if (match) {
      if (match[1]) {
        var rev_alts = List.rev(alts);
        return Curry._2(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "one of ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    " or ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ]),
                        "one of %s or %s"
                      ]), $$String.concat(", ", List.rev_map(quote$1, List.tl(rev_alts))), Curry._1(quote$1, List.hd(rev_alts)));
      } else {
        return Curry._2(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "either ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    " or ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ]),
                        "either %s or %s"
                      ]), Curry._1(quote$1, a), Curry._1(quote$1, match[0]));
      }
    } else {
      return Curry._1(quote$1, a);
    }
  } else {
    return Pervasives.invalid_arg(err_empty_list);
  }
}

function err_multi_def(kind, name, doc, v, v$prime) {
  return Curry._4(Printf.sprintf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */Block.__(12, [
                          /* " " */32,
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  " defined twice (doc strings are '",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* String_literal */Block.__(11, [
                                          "' and '",
                                          /* String */Block.__(2, [
                                              /* No_padding */0,
                                              /* String_literal */Block.__(11, [
                                                  "')",
                                                  /* End_of_format */0
                                                ])
                                            ])
                                        ])
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "%s %s defined twice (doc strings are '%s' and '%s')"
                ]), kind, name, Curry._1(doc, v), Curry._1(doc, v$prime));
}

function err_ambiguous(kind, s, ambs) {
  return Curry._3(Printf.sprintf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* Char_literal */Block.__(12, [
                          /* " " */32,
                          /* String */Block.__(2, [
                              /* No_padding */0,
                              /* String_literal */Block.__(11, [
                                  " ambiguous and could be ",
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "%s %s ambiguous and could be %s"
                ]), kind, quote(s), alts_str(/* None */0, ambs));
}

function err_unknown($staropt$star, kind, v) {
  var hints = $staropt$star ? $staropt$star[0] : /* [] */0;
  var did_you_mean = function (s) {
    return Curry._1(Printf.sprintf(/* Format */[
                    /* String_literal */Block.__(11, [
                        ", did you mean ",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                " ?",
                                /* End_of_format */0
                              ])
                          ])
                      ]),
                    ", did you mean %s ?"
                  ]), s);
  };
  var hints$1 = hints ? did_you_mean(alts_str(/* None */0, hints)) : ".";
  return Curry._3(Printf.sprintf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "unknown ",
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* " " */32,
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String */Block.__(2, [
                                      /* No_padding */0,
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "unknown %s %s%s"
                ]), kind, quote(v), hints$1);
}

function err_no(kind, s) {
  return Curry._2(Printf.sprintf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "no ",
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* " " */32,
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ])
                        ])
                    ]),
                  "no %s %s"
                ]), quote(s), kind);
}

function err_not_dir(s) {
  return Curry._1(Printf.sprintf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* String_literal */Block.__(11, [
                          " is not a directory",
                          /* End_of_format */0
                        ])
                    ]),
                  "%s is not a directory"
                ]), quote(s));
}

function err_is_dir(s) {
  return Curry._1(Printf.sprintf(/* Format */[
                  /* String */Block.__(2, [
                      /* No_padding */0,
                      /* String_literal */Block.__(11, [
                          " is a directory",
                          /* End_of_format */0
                        ])
                    ]),
                  "%s is a directory"
                ]), quote(s));
}

function err_element(kind, s, exp) {
  return Curry._3(Printf.sprintf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "invalid element in ",
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String_literal */Block.__(11, [
                              " (`",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      "'): ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "invalid element in %s (`%s'): %s"
                ]), kind, s, exp);
}

function err_invalid(kind, s, exp) {
  return Curry._3(Printf.sprintf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "invalid ",
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* Char_literal */Block.__(12, [
                              /* " " */32,
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      ", ",
                                      /* String */Block.__(2, [
                                          /* No_padding */0,
                                          /* End_of_format */0
                                        ])
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "invalid %s %s, %s"
                ]), kind, quote(s), exp);
}

function err_sep_miss(sep, s) {
  return err_invalid("value", s, Curry._1(Printf.sprintf(/* Format */[
                      /* String_literal */Block.__(11, [
                          "missing a `",
                          /* Char */Block.__(0, [/* String_literal */Block.__(11, [
                                  "' separator",
                                  /* End_of_format */0
                                ])])
                        ]),
                      "missing a `%c' separator"
                    ]), sep));
}

function some($staropt$star, param) {
  var print = param[1];
  var parse = param[0];
  var none = $staropt$star ? $staropt$star[0] : "";
  var parse$1 = function (s) {
    var e = Curry._1(parse, s);
    if (e[0] >= 106380200) {
      return e;
    } else {
      return /* `Ok */[
              17724,
              /* Some */[e[1]]
            ];
    }
  };
  var print$1 = function (ppf, v) {
    if (v) {
      return Curry._2(print, ppf, v[0]);
    } else {
      return Format.pp_print_string(ppf, none);
    }
  };
  return /* tuple */[
          parse$1,
          print$1
        ];
}

function parse(s) {
  try {
    return /* `Ok */[
            17724,
            Pervasives.bool_of_string(s)
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return /* `Error */[
              106380200,
              err_invalid("value", s, alts_str(/* None */0, /* :: */[
                        "true",
                        /* :: */[
                          "false",
                          /* [] */0
                        ]
                      ]))
            ];
    } else {
      throw exn;
    }
  }
}

var bool = /* tuple */[
  parse,
  Format.pp_print_bool
];

function parse$1(s) {
  var match = +(s.length === 1);
  if (match !== 0) {
    return /* `Ok */[
            17724,
            Caml_string.get(s, 0)
          ];
  } else {
    return /* `Error */[
            106380200,
            err_invalid("value", s, "expected a character")
          ];
  }
}

var $$char = /* tuple */[
  parse$1,
  Format.pp_print_char
];

function parse_with(t_of_str, exp, s) {
  try {
    return /* `Ok */[
            17724,
            Curry._1(t_of_str, s)
          ];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return /* `Error */[
              106380200,
              err_invalid("value", s, exp)
            ];
    } else {
      throw exn;
    }
  }
}

function int_000(param) {
  return parse_with(Caml_format.caml_int_of_string, "expected an integer", param);
}

var $$int = /* tuple */[
  int_000,
  Format.pp_print_int
];

function int32_000(param) {
  return parse_with(Caml_format.caml_int32_of_string, "expected a 32-bit integer", param);
}

function int32_001(ppf) {
  return Format.fprintf(ppf, /* Format */[
              /* Int32 */Block.__(5, [
                  /* Int_d */0,
                  /* No_padding */0,
                  /* No_precision */0,
                  /* End_of_format */0
                ]),
              "%ld"
            ]);
}

var int32 = /* tuple */[
  int32_000,
  int32_001
];

function int64_000(param) {
  return parse_with(Caml_format.caml_int64_of_string, "expected a 64-bit integer", param);
}

function int64_001(ppf) {
  return Format.fprintf(ppf, /* Format */[
              /* Int64 */Block.__(7, [
                  /* Int_d */0,
                  /* No_padding */0,
                  /* No_precision */0,
                  /* End_of_format */0
                ]),
              "%Ld"
            ]);
}

var int64 = /* tuple */[
  int64_000,
  int64_001
];

function nativeint_000(param) {
  return parse_with(Caml_format.caml_nativeint_of_string, "expected a processor-native integer", param);
}

function nativeint_001(ppf) {
  return Format.fprintf(ppf, /* Format */[
              /* Nativeint */Block.__(6, [
                  /* Int_d */0,
                  /* No_padding */0,
                  /* No_precision */0,
                  /* End_of_format */0
                ]),
              "%nd"
            ]);
}

var nativeint = /* tuple */[
  nativeint_000,
  nativeint_001
];

function float_000(param) {
  return parse_with(Caml_format.caml_float_of_string, "expected a floating point number", param);
}

var $$float = /* tuple */[
  float_000,
  Format.pp_print_float
];

function string_000(s) {
  return /* `Ok */[
          17724,
          s
        ];
}

var string = /* tuple */[
  string_000,
  Format.pp_print_string
];

function $$enum(sl) {
  if (sl) {
    var t = Cmdliner_trie.of_list(sl);
    var parse = function (s) {
      var r = Cmdliner_trie.find(t, s);
      if (typeof r === "number") {
        if (r >= -328798100) {
          var ambs = List.sort(Caml_obj.caml_compare, Cmdliner_trie.ambiguities(t, s));
          return /* `Error */[
                  106380200,
                  err_ambiguous("enum value", s, ambs)
                ];
        } else {
          var alts = List.rev(List.rev_map((function (param) {
                      return param[0];
                    }), sl));
          return /* `Error */[
                  106380200,
                  err_invalid("value", s, "expected " + alts_str(/* None */0, alts))
                ];
        }
      } else {
        return r;
      }
    };
    var print = function (ppf, v) {
      var sl_inv = List.rev_map((function (param) {
              return /* tuple */[
                      param[1],
                      param[0]
                    ];
            }), sl);
      try {
        return Format.pp_print_string(ppf, List.assoc(v, sl_inv));
      }
      catch (exn){
        if (exn === Caml_builtin_exceptions.not_found) {
          return Pervasives.invalid_arg("Incomplete enumeration for the type");
        } else {
          throw exn;
        }
      }
    };
    return /* tuple */[
            parse,
            print
          ];
  } else {
    return Pervasives.invalid_arg(err_empty_list);
  }
}

function parse$2(s) {
  var match = Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n");
  if (match !== 0) {
    return /* `Ok */[
            17724,
            s
          ];
  } else {
    return /* `Error */[
            106380200,
            err_no("file or directory", s)
          ];
  }
}

var file = /* tuple */[
  parse$2,
  Format.pp_print_string
];

function parse$3(s) {
  var match = Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n");
  if (match !== 0) {
    if (Caml_sys.caml_sys_is_directory(s)) {
      return /* `Ok */[
              17724,
              s
            ];
    } else {
      return /* `Error */[
              106380200,
              err_not_dir(s)
            ];
    }
  } else {
    return /* `Error */[
            106380200,
            err_no("directory", s)
          ];
  }
}

var dir = /* tuple */[
  parse$3,
  Format.pp_print_string
];

function parse$4(s) {
  var match = Caml_missing_polyfill.not_implemented("caml_sys_file_exists not implemented by bucklescript yet\n");
  if (match !== 0) {
    if (Caml_sys.caml_sys_is_directory(s)) {
      return /* `Error */[
              106380200,
              err_is_dir(s)
            ];
    } else {
      return /* `Ok */[
              17724,
              s
            ];
    }
  } else {
    return /* `Error */[
            106380200,
            err_no("file", s)
          ];
  }
}

var non_dir_file = /* tuple */[
  parse$4,
  Format.pp_print_string
];

function split_and_parse(sep, parse, s) {
  var parse$1 = function (sub) {
    var match = Curry._1(parse, sub);
    if (match[0] >= 106380200) {
      return Pervasives.failwith(match[1]);
    } else {
      return match[1];
    }
  };
  var _accum = /* [] */0;
  var _j = s.length - 1 | 0;
  while(true) {
    var j = _j;
    var accum = _accum;
    var i;
    try {
      i = $$String.rindex_from(s, j, sep);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        i = -1;
      } else {
        throw exn;
      }
    }
    if (i === -1) {
      var p = $$String.sub(s, 0, j + 1 | 0);
      if (p !== "") {
        return /* :: */[
                parse$1(p),
                accum
              ];
      } else {
        return accum;
      }
    } else {
      var p$1 = $$String.sub(s, i + 1 | 0, j - i | 0);
      var accum$prime = p$1 !== "" ? /* :: */[
          parse$1(p$1),
          accum
        ] : accum;
      _j = i - 1 | 0;
      _accum = accum$prime;
      continue ;
      
    }
  };
}

function list($staropt$star, param) {
  var pp_e = param[1];
  var parse = param[0];
  var sep = $staropt$star ? $staropt$star[0] : /* "," */44;
  var parse$1 = function (s) {
    try {
      return /* `Ok */[
              17724,
              split_and_parse(sep, parse, s)
            ];
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return /* `Error */[
                106380200,
                err_element("list", s, exn[1])
              ];
      } else {
        throw exn;
      }
    }
  };
  var print = function (ppf, _param) {
    while(true) {
      var param = _param;
      if (param) {
        var l = param[1];
        Curry._2(pp_e, ppf, param[0]);
        if (l !== /* [] */0) {
          Format.pp_print_char(ppf, sep);
          _param = l;
          continue ;
          
        } else {
          return 0;
        }
      } else {
        return /* () */0;
      }
    };
  };
  return /* tuple */[
          parse$1,
          print
        ];
}

function array($staropt$star, param) {
  var pp_e = param[1];
  var parse = param[0];
  var sep = $staropt$star ? $staropt$star[0] : /* "," */44;
  var parse$1 = function (s) {
    try {
      return /* `Ok */[
              17724,
              $$Array.of_list(split_and_parse(sep, parse, s))
            ];
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return /* `Error */[
                106380200,
                err_element("array", s, exn[1])
              ];
      } else {
        throw exn;
      }
    }
  };
  var print = function (ppf, v) {
    var max = v.length - 1 | 0;
    for(var i = 0; i <= max; ++i){
      Curry._2(pp_e, ppf, Caml_array.caml_array_get(v, i));
      if (i !== max) {
        Format.pp_print_char(ppf, sep);
      }
      
    }
    return /* () */0;
  };
  return /* tuple */[
          parse$1,
          print
        ];
}

function split_left(sep, s) {
  try {
    var i = $$String.index(s, sep);
    var len = s.length;
    return /* Some */[/* tuple */[
              $$String.sub(s, 0, i),
              $$String.sub(s, i + 1 | 0, (len - i | 0) - 1 | 0)
            ]];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function pair($staropt$star, param, param$1) {
  var pr1 = param$1[1];
  var pa1 = param$1[0];
  var pr0 = param[1];
  var pa0 = param[0];
  var sep = $staropt$star ? $staropt$star[0] : /* "," */44;
  var parser = function (s) {
    var match = split_left(sep, s);
    if (match) {
      var match$1 = match[0];
      var match$2 = Curry._1(pa0, match$1[0]);
      var match$3 = Curry._1(pa1, match$1[1]);
      var exit = 0;
      if (match$2[0] >= 106380200) {
        return /* `Error */[
                106380200,
                err_element("pair", s, match$2[1])
              ];
      } else if (typeof match$3 === "number") {
        exit = 1;
      } else if (match$3[0] !== 17724) {
        exit = 1;
      } else {
        return /* `Ok */[
                17724,
                /* tuple */[
                  match$2[1],
                  match$3[1]
                ]
              ];
      }
      if (exit === 1) {
        return /* `Error */[
                106380200,
                err_element("pair", s, match$3[1])
              ];
      }
      
    } else {
      return /* `Error */[
              106380200,
              err_sep_miss(sep, s)
            ];
    }
  };
  var printer = function (ppf, param) {
    return Curry._5(Format.fprintf(ppf, /* Format */[
                    /* Alpha */Block.__(15, [/* Char */Block.__(0, [/* Alpha */Block.__(15, [/* End_of_format */0])])]),
                    "%a%c%a"
                  ]), pr0, param[0], sep, pr1, param[1]);
  };
  return /* tuple */[
          parser,
          printer
        ];
}

function t3($staropt$star, param, param$1, param$2) {
  var pr2 = param$2[1];
  var pa2 = param$2[0];
  var pr1 = param$1[1];
  var pa1 = param$1[0];
  var pr0 = param[1];
  var pa0 = param[0];
  var sep = $staropt$star ? $staropt$star[0] : /* "," */44;
  var parse = function (s) {
    var match = split_left(sep, s);
    if (match) {
      var match$1 = match[0];
      var s$1 = match$1[1];
      var match$2 = split_left(sep, s$1);
      if (match$2) {
        var match$3 = match$2[0];
        var match$4 = Curry._1(pa0, match$1[0]);
        var match$5 = Curry._1(pa1, match$3[0]);
        var match$6 = Curry._1(pa2, match$3[1]);
        var exit = 0;
        var e;
        var exit$1 = 0;
        if (match$4[0] >= 106380200) {
          e = match$4[1];
          exit = 1;
        } else if (typeof match$5 === "number") {
          exit$1 = 2;
        } else if (match$5[0] !== 17724) {
          exit$1 = 2;
        } else if (typeof match$6 === "number") {
          e = match$6[1];
          exit = 1;
        } else if (match$6[0] !== 17724) {
          e = match$6[1];
          exit = 1;
        } else {
          return /* `Ok */[
                  17724,
                  /* tuple */[
                    match$4[1],
                    match$5[1],
                    match$6[1]
                  ]
                ];
        }
        if (exit$1 === 2) {
          if (typeof match$5 === "number") {
            e = match$6[1];
            exit = 1;
          } else if (match$5[0] !== 106380200) {
            e = match$6[1];
            exit = 1;
          } else {
            e = match$5[1];
            exit = 1;
          }
        }
        if (exit === 1) {
          return /* `Error */[
                  106380200,
                  err_element("triple", s$1, e)
                ];
        }
        
      } else {
        return /* `Error */[
                106380200,
                err_sep_miss(sep, s$1)
              ];
      }
    } else {
      return /* `Error */[
              106380200,
              err_sep_miss(sep, s)
            ];
    }
  };
  var print = function (ppf, param) {
    return Curry._8(Format.fprintf(ppf, /* Format */[
                    /* Alpha */Block.__(15, [/* Char */Block.__(0, [/* Alpha */Block.__(15, [/* Char */Block.__(0, [/* Alpha */Block.__(15, [/* End_of_format */0])])])])]),
                    "%a%c%a%c%a"
                  ]), pr0, param[0], sep, pr1, param[1], sep, pr2, param[2]);
  };
  return /* tuple */[
          parse,
          print
        ];
}

function t4($staropt$star, param, param$1, param$2, param$3) {
  var pr3 = param$3[1];
  var pa3 = param$3[0];
  var pr2 = param$2[1];
  var pa2 = param$2[0];
  var pr1 = param$1[1];
  var pa1 = param$1[0];
  var pr0 = param[1];
  var pa0 = param[0];
  var sep = $staropt$star ? $staropt$star[0] : /* "," */44;
  var parse = function (s) {
    var match = split_left(sep, s);
    if (match) {
      var match$1 = match[0];
      var s$1 = match$1[1];
      var match$2 = split_left(sep, s$1);
      if (match$2) {
        var match$3 = match$2[0];
        var s$2 = match$3[1];
        var match$4 = split_left(sep, s$2);
        if (match$4) {
          var match$5 = match$4[0];
          var match$6 = Curry._1(pa0, match$1[0]);
          var match$7 = Curry._1(pa1, match$3[0]);
          var match$8 = Curry._1(pa2, match$5[0]);
          var match$9 = Curry._1(pa3, match$5[1]);
          var exit = 0;
          var e;
          var exit$1 = 0;
          var exit$2 = 0;
          if (match$6[0] >= 106380200) {
            e = match$6[1];
            exit = 1;
          } else if (typeof match$7 === "number") {
            exit$2 = 3;
          } else if (match$7[0] !== 17724) {
            exit$2 = 3;
          } else if (typeof match$8 === "number") {
            exit$1 = 2;
          } else if (match$8[0] !== 17724) {
            exit$1 = 2;
          } else if (typeof match$9 === "number") {
            e = match$9[1];
            exit = 1;
          } else if (match$9[0] !== 17724) {
            e = match$9[1];
            exit = 1;
          } else {
            return /* `Ok */[
                    17724,
                    /* tuple */[
                      match$6[1],
                      match$7[1],
                      match$8[1],
                      match$9[1]
                    ]
                  ];
          }
          if (exit$2 === 3) {
            if (typeof match$7 === "number") {
              exit$1 = 2;
            } else if (match$7[0] !== 106380200) {
              exit$1 = 2;
            } else {
              e = match$7[1];
              exit = 1;
            }
          }
          if (exit$1 === 2) {
            if (typeof match$8 === "number") {
              e = match$9[1];
              exit = 1;
            } else if (match$8[0] !== 106380200) {
              e = match$9[1];
              exit = 1;
            } else {
              e = match$8[1];
              exit = 1;
            }
          }
          if (exit === 1) {
            return /* `Error */[
                    106380200,
                    err_element("quadruple", s$2, e)
                  ];
          }
          
        } else {
          return /* `Error */[
                  106380200,
                  err_sep_miss(sep, s$2)
                ];
        }
      } else {
        return /* `Error */[
                106380200,
                err_sep_miss(sep, s$1)
              ];
      }
    } else {
      return /* `Error */[
              106380200,
              err_sep_miss(sep, s)
            ];
    }
  };
  var print = function (ppf, param) {
    return Curry.app(Format.fprintf(ppf, /* Format */[
                    /* Alpha */Block.__(15, [/* Char */Block.__(0, [/* Alpha */Block.__(15, [/* Char */Block.__(0, [/* Alpha */Block.__(15, [/* Char */Block.__(0, [/* Alpha */Block.__(15, [/* End_of_format */0])])])])])])]),
                    "%a%c%a%c%a%c%a"
                  ]), [
                pr0,
                param[0],
                sep,
                pr1,
                param[1],
                sep,
                pr2,
                param[2],
                sep,
                pr3,
                param[3]
              ]);
  };
  return /* tuple */[
          parse,
          print
        ];
}

function env_bool_parse(s) {
  var s$1 = $$String.lowercase(s);
  switch (s$1) {
    case "" : 
    case "0" : 
    case "false" : 
    case "n" : 
    case "no" : 
        return /* `Ok */[
                17724,
                /* false */0
              ];
    case "1" : 
    case "true" : 
    case "y" : 
    case "yes" : 
        return /* `Ok */[
                17724,
                /* true */1
              ];
    default:
      return /* `Error */[
              106380200,
              err_invalid("value", s$1, alts_str(/* None */0, /* :: */[
                        "true",
                        /* :: */[
                          "yes",
                          /* :: */[
                            "false",
                            /* :: */[
                              "no",
                              /* [] */0
                            ]
                          ]
                        ]
                      ]))
            ];
  }
}

var lowercase = $$String.lowercase;

var uppercase = $$String.lowercase;

var capitalize = $$String.capitalize;

var t2 = pair;

exports.lowercase = lowercase;
exports.uppercase = uppercase;
exports.capitalize = capitalize;
exports.pp_text = pp_text;
exports.pp_lines = pp_lines;
exports.pp_tokens = pp_tokens;
exports.quote = quote;
exports.alts_str = alts_str;
exports.err_ambiguous = err_ambiguous;
exports.err_unknown = err_unknown;
exports.err_multi_def = err_multi_def;
exports.some = some;
exports.bool = bool;
exports.$$char = $$char;
exports.$$int = $$int;
exports.nativeint = nativeint;
exports.int32 = int32;
exports.int64 = int64;
exports.$$float = $$float;
exports.string = string;
exports.$$enum = $$enum;
exports.file = file;
exports.dir = dir;
exports.non_dir_file = non_dir_file;
exports.list = list;
exports.array = array;
exports.pair = pair;
exports.t2 = t2;
exports.t3 = t3;
exports.t4 = t4;
exports.env_bool_parse = env_bool_parse;
/* Format Not a pure module */
