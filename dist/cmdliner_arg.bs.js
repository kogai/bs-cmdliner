// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Cmdliner_msg = require("./cmdliner_msg.bs.js");
var Cmdliner_base = require("./cmdliner_base.bs.js");
var Cmdliner_info = require("./cmdliner_info.bs.js");
var Cmdliner_cline = require("./cmdliner_cline.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function rev_compare(n0, n1) {
  return Caml_obj.caml_compare(n1, n0);
}

var err_not_opt = "Option argument without name";

var err_not_pos = "Positional argument with a name";

function doc_alts_enum(quoted, $$enum) {
  return Cmdliner_base.alts_str(quoted, List.map((function (prim) {
                    return prim[0];
                  }), $$enum));
}

function str_of_pp(pp, v) {
  Curry._2(pp, Format.str_formatter, v);
  return Format.flush_str_formatter(/* () */0);
}

function conv(_, param) {
  var parse = param[0];
  var parse$1 = function (s) {
    var match = Curry._1(parse, s);
    if (match.tag) {
      return /* `Error */[
              106380200,
              match[0][1]
            ];
    } else {
      return /* `Ok */[
              17724,
              match[0]
            ];
    }
  };
  return /* tuple */[
          parse$1,
          param[1]
        ];
}

function pconv(_, conv) {
  return conv;
}

function conv_parser(param, s) {
  var match = Curry._1(param[0], s);
  if (match[0] >= 106380200) {
    return /* Error */Block.__(1, [/* `Msg */[
                3854881,
                match[1]
              ]]);
  } else {
    return /* Ok */Block.__(0, [match[1]]);
  }
}

function conv_printer(param) {
  return param[1];
}

function conv_docv() {
  return "VALUE";
}

function err_invalid(s, kind) {
  return /* `Msg */[
          3854881,
          Curry._2(Printf.sprintf(/* Format */[
                    /* String_literal */Block.__(11, [
                        "invalid value '",
                        /* String */Block.__(2, [
                            /* No_padding */0,
                            /* String_literal */Block.__(11, [
                                "', expected ",
                                /* String */Block.__(2, [
                                    /* No_padding */0,
                                    /* End_of_format */0
                                  ])
                              ])
                          ])
                      ]),
                    "invalid value '%s', expected %s"
                  ]), s, kind)
        ];
}

function parser_of_kind_of_string(kind, k_of_string, s) {
  var match = Curry._1(k_of_string, s);
  if (match) {
    return /* Ok */Block.__(0, [match[0]]);
  } else {
    return /* Error */Block.__(1, [err_invalid(s, kind)]);
  }
}

function $unknown(f, x) {
  return Curry._1(f, x);
}

function parse_to_list(parser, s) {
  var e = Curry._1(parser, s);
  if (e[0] >= 106380200) {
    return e;
  } else {
    return /* `Ok */[
            17724,
            /* :: */[
              e[1],
              /* [] */0
            ]
          ];
  }
}

function try_env(ei, a, parse, absent) {
  var match = Cmdliner_info.arg_env(a);
  if (match) {
    var env = match[0];
    var $$var = Cmdliner_info.env_var(env);
    var match$1 = Cmdliner_info.eval_env_var(ei, $$var);
    if (match$1) {
      var match$2 = Curry._1(parse, match$1[0]);
      if (match$2[0] >= 106380200) {
        var e = Cmdliner_msg.err_env_parse(env, match$2[1]);
        return /* Error */Block.__(1, [/* `Parse */[
                    -796721133,
                    e
                  ]]);
      } else {
        return /* Ok */Block.__(0, [match$2[1]]);
      }
    } else {
      return /* Ok */Block.__(0, [absent]);
    }
  } else {
    return /* Ok */Block.__(0, [absent]);
  }
}

var arg_to_args = Cmdliner_info.Args[/* singleton */4];

function list_to_args(f, l) {
  var add = function (acc, v) {
    return Curry._2(Cmdliner_info.Args[/* add */3], Curry._1(f, v), acc);
  };
  return List.fold_left(add, Cmdliner_info.Args[/* empty */0], l);
}

function flag(a) {
  if (Cmdliner_info.arg_is_pos(a)) {
    return Pervasives.invalid_arg(err_not_opt);
  } else {
    var convert = function (ei, cl) {
      var match = Cmdliner_cline.opt_arg(cl, a);
      if (match) {
        var match$1 = match[0];
        var match$2 = match$1[2];
        var f = match$1[1];
        var exit = 0;
        if (match$2) {
          if (match[1]) {
            exit = 1;
          } else {
            var e = Cmdliner_msg.err_flag_value(f, match$2[0]);
            return /* Error */Block.__(1, [/* `Parse */[
                        -796721133,
                        e
                      ]]);
          }
        } else if (match[1]) {
          exit = 1;
        } else {
          return /* Ok */Block.__(0, [/* true */1]);
        }
        if (exit === 1) {
          var e$1 = Cmdliner_msg.err_opt_repeated(f, match[1][0][1]);
          return /* Error */Block.__(1, [/* `Parse */[
                      -796721133,
                      e$1
                    ]]);
        }
        
      } else {
        return try_env(ei, a, Cmdliner_base.env_bool_parse, /* false */0);
      }
    };
    return /* tuple */[
            Curry._1(arg_to_args, a),
            convert
          ];
  }
}

function flag_all(a) {
  if (Cmdliner_info.arg_is_pos(a)) {
    return Pervasives.invalid_arg(err_not_opt);
  } else {
    var a$1 = Cmdliner_info.arg_make_all_opts(a);
    var convert = function (ei, cl) {
      var l = Cmdliner_cline.opt_arg(cl, a$1);
      if (l) {
        try {
          var truth = function (param) {
            var v = param[2];
            if (v) {
              return Pervasives.failwith(Cmdliner_msg.err_flag_value(param[1], v[0]));
            } else {
              return /* true */1;
            }
          };
          return /* Ok */Block.__(0, [List.rev_map(truth, l)]);
        }
        catch (raw_exn){
          var exn = Js_exn.internalToOCamlException(raw_exn);
          if (exn[0] === Caml_builtin_exceptions.failure) {
            return /* Error */Block.__(1, [/* `Parse */[
                        -796721133,
                        exn[1]
                      ]]);
          } else {
            throw exn;
          }
        }
      } else {
        return try_env(ei, a$1, (function (param) {
                      return parse_to_list(Cmdliner_base.env_bool_parse, param);
                    }), /* [] */0);
      }
    };
    return /* tuple */[
            Curry._1(arg_to_args, a$1),
            convert
          ];
  }
}

function vflag(v, l) {
  var convert = function (_, cl) {
    var aux = function (_fv, _param) {
      while(true) {
        var param = _param;
        var fv = _fv;
        if (param) {
          var rest = param[1];
          var match = param[0];
          var match$1 = Cmdliner_cline.opt_arg(cl, match[1]);
          if (match$1) {
            var match$2 = match$1[0];
            var match$3 = match$2[2];
            var f = match$2[1];
            var exit = 0;
            if (match$3) {
              if (match$1[1]) {
                exit = 1;
              } else {
                return Pervasives.failwith(Cmdliner_msg.err_flag_value(f, match$3[0]));
              }
            } else if (match$1[1]) {
              exit = 1;
            } else if (fv) {
              return Pervasives.failwith(Cmdliner_msg.err_opt_repeated(fv[0][0], f));
            } else {
              _param = rest;
              _fv = /* Some */[/* tuple */[
                  f,
                  match[0]
                ]];
              continue ;
              
            }
            if (exit === 1) {
              return Pervasives.failwith(Cmdliner_msg.err_opt_repeated(match$1[1][0][1], f));
            }
            
          } else {
            _param = rest;
            continue ;
            
          }
        } else if (fv) {
          return fv[0][1];
        } else {
          return v;
        }
      };
    };
    try {
      return /* Ok */Block.__(0, [aux(/* None */0, l)]);
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return /* Error */Block.__(1, [/* `Parse */[
                    -796721133,
                    exn[1]
                  ]]);
      } else {
        throw exn;
      }
    }
  };
  var flag = function (param) {
    var a = param[1];
    if (Cmdliner_info.arg_is_pos(a)) {
      return Pervasives.invalid_arg(err_not_opt);
    } else {
      return a;
    }
  };
  return /* tuple */[
          list_to_args(flag, l),
          convert
        ];
}

function vflag_all(v, l) {
  var convert = function (_, cl) {
    var aux = function (_acc, _param) {
      while(true) {
        var param = _param;
        var acc = _acc;
        if (param) {
          var rest = param[1];
          var match = param[0];
          var fv = match[0];
          var l = Cmdliner_cline.opt_arg(cl, match[1]);
          if (l) {
            var fval = (function(fv){
            return function fval(param) {
              var v = param[2];
              if (v) {
                return Pervasives.failwith(Cmdliner_msg.err_flag_value(param[1], v[0]));
              } else {
                return /* tuple */[
                        param[0],
                        fv
                      ];
              }
            }
            }(fv));
            _param = rest;
            _acc = List.rev_append(List.rev_map(fval, l), acc);
            continue ;
            
          } else {
            _param = rest;
            continue ;
            
          }
        } else if (acc) {
          return List.rev_map((function (prim) {
                        return prim[1];
                      }), List.sort(rev_compare, acc));
        } else {
          return v;
        }
      };
    };
    try {
      return /* Ok */Block.__(0, [aux(/* [] */0, l)]);
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return /* Error */Block.__(1, [/* `Parse */[
                    -796721133,
                    exn[1]
                  ]]);
      } else {
        throw exn;
      }
    }
  };
  var flag = function (param) {
    var a = param[1];
    if (Cmdliner_info.arg_is_pos(a)) {
      return Pervasives.invalid_arg(err_not_opt);
    } else {
      return Cmdliner_info.arg_make_all_opts(a);
    }
  };
  return /* tuple */[
          list_to_args(flag, l),
          convert
        ];
}

function parse_opt_value(parse, f, v) {
  var match = Curry._1(parse, v);
  if (match[0] >= 106380200) {
    return Pervasives.failwith(Cmdliner_msg.err_opt_parse(f, match[1]));
  } else {
    return match[1];
  }
}

function opt(vopt, param, v, a) {
  var print = param[1];
  var parse = param[0];
  if (Cmdliner_info.arg_is_pos(a)) {
    return Pervasives.invalid_arg(err_not_opt);
  } else {
    var absent = /* Val */[Block.__(246, [(function () {
              return str_of_pp(print, v);
            })])];
    var kind = vopt ? /* Opt_vopt */[str_of_pp(print, vopt[0])] : /* Opt */1;
    var a$1 = Cmdliner_info.arg_make_opt(absent, kind, a);
    var convert = function (ei, cl) {
      var match = Cmdliner_cline.opt_arg(cl, a$1);
      if (match) {
        var match$1 = match[0];
        var match$2 = match$1[2];
        var f = match$1[1];
        var exit = 0;
        if (match$2) {
          if (match[1]) {
            exit = 1;
          } else {
            try {
              return /* Ok */Block.__(0, [parse_opt_value(parse, f, match$2[0])]);
            }
            catch (raw_exn){
              var exn = Js_exn.internalToOCamlException(raw_exn);
              if (exn[0] === Caml_builtin_exceptions.failure) {
                return /* Error */Block.__(1, [/* `Parse */[
                            -796721133,
                            exn[1]
                          ]]);
              } else {
                throw exn;
              }
            }
          }
        } else if (match[1]) {
          exit = 1;
        } else if (vopt) {
          return /* Ok */Block.__(0, [vopt[0]]);
        } else {
          var e = Cmdliner_msg.err_opt_value_missing(f);
          return /* Error */Block.__(1, [/* `Parse */[
                      -796721133,
                      e
                    ]]);
        }
        if (exit === 1) {
          var e$1 = Cmdliner_msg.err_opt_repeated(match[1][0][1], f);
          return /* Error */Block.__(1, [/* `Parse */[
                      -796721133,
                      e$1
                    ]]);
        }
        
      } else {
        return try_env(ei, a$1, parse, v);
      }
    };
    return /* tuple */[
            Curry._1(arg_to_args, a$1),
            convert
          ];
  }
}

function opt_all(vopt, param, v, a) {
  var parse = param[0];
  if (Cmdliner_info.arg_is_pos(a)) {
    return Pervasives.invalid_arg(err_not_opt);
  } else {
    var kind = vopt ? /* Opt_vopt */[str_of_pp(param[1], vopt[0])] : /* Opt */1;
    var a$1 = Cmdliner_info.arg_make_opt_all(/* Val */[""], kind, a);
    var convert = function (ei, cl) {
      var l = Cmdliner_cline.opt_arg(cl, a$1);
      if (l) {
        var parse$1 = function (param) {
          var v = param[2];
          var f = param[1];
          var k = param[0];
          if (v) {
            return /* tuple */[
                    k,
                    parse_opt_value(parse, f, v[0])
                  ];
          } else if (vopt) {
            return /* tuple */[
                    k,
                    vopt[0]
                  ];
          } else {
            return Pervasives.failwith(Cmdliner_msg.err_opt_value_missing(f));
          }
        };
        try {
          return /* Ok */Block.__(0, [List.rev_map((function (prim) {
                            return prim[1];
                          }), List.sort(rev_compare, List.rev_map(parse$1, l)))]);
        }
        catch (raw_exn){
          var exn = Js_exn.internalToOCamlException(raw_exn);
          if (exn[0] === Caml_builtin_exceptions.failure) {
            return /* Error */Block.__(1, [/* `Parse */[
                        -796721133,
                        exn[1]
                      ]]);
          } else {
            throw exn;
          }
        }
      } else {
        return try_env(ei, a$1, (function (param) {
                      return parse_to_list(parse, param);
                    }), v);
      }
    };
    return /* tuple */[
            Curry._1(arg_to_args, a$1),
            convert
          ];
  }
}

function parse_pos_value(parse, a, v) {
  var match = Curry._1(parse, v);
  if (match[0] >= 106380200) {
    return Pervasives.failwith(Cmdliner_msg.err_pos_parse(a, match[1]));
  } else {
    return match[1];
  }
}

function pos($staropt$star, k, param, v, a) {
  var print = param[1];
  var parse = param[0];
  var rev = $staropt$star ? $staropt$star[0] : /* false */0;
  if (Cmdliner_info.arg_is_opt(a)) {
    return Pervasives.invalid_arg(err_not_pos);
  } else {
    var absent = /* Val */[Block.__(246, [(function () {
              return str_of_pp(print, v);
            })])];
    var pos$1 = Cmdliner_info.pos(rev, k, /* Some */[1]);
    var a$1 = Cmdliner_info.arg_make_pos_abs(absent, pos$1, a);
    var convert = function (ei, cl) {
      var match = Cmdliner_cline.pos_arg(cl, a$1);
      if (match) {
        if (match[1]) {
          throw [
                Caml_builtin_exceptions.assert_failure,
                [
                  "cmdliner_arg.ml",
                  227,
                  9
                ]
              ];
        } else {
          try {
            return /* Ok */Block.__(0, [parse_pos_value(parse, a$1, match[0])]);
          }
          catch (raw_exn){
            var exn = Js_exn.internalToOCamlException(raw_exn);
            if (exn[0] === Caml_builtin_exceptions.failure) {
              return /* Error */Block.__(1, [/* `Parse */[
                          -796721133,
                          exn[1]
                        ]]);
            } else {
              throw exn;
            }
          }
        }
      } else {
        return try_env(ei, a$1, parse, v);
      }
    };
    return /* tuple */[
            Curry._1(arg_to_args, a$1),
            convert
          ];
  }
}

function pos_list(pos, param, v, a) {
  var parse = param[0];
  if (Cmdliner_info.arg_is_opt(a)) {
    return Pervasives.invalid_arg(err_not_pos);
  } else {
    var a$1 = Cmdliner_info.arg_make_pos(pos, a);
    var convert = function (ei, cl) {
      var l = Cmdliner_cline.pos_arg(cl, a$1);
      if (l) {
        try {
          return /* Ok */Block.__(0, [List.rev(List.rev_map((function (param) {
                                return parse_pos_value(parse, a$1, param);
                              }), l))]);
        }
        catch (raw_exn){
          var exn = Js_exn.internalToOCamlException(raw_exn);
          if (exn[0] === Caml_builtin_exceptions.failure) {
            return /* Error */Block.__(1, [/* `Parse */[
                        -796721133,
                        exn[1]
                      ]]);
          } else {
            throw exn;
          }
        }
      } else {
        return try_env(ei, a$1, (function (param) {
                      return parse_to_list(parse, param);
                    }), v);
      }
    };
    return /* tuple */[
            Curry._1(arg_to_args, a$1),
            convert
          ];
  }
}

var all = Cmdliner_info.pos(/* false */0, 0, /* None */0);

function pos_all(c, v, a) {
  return pos_list(all, c, v, a);
}

function pos_left($staropt$star, k) {
  var rev = $staropt$star ? $staropt$star[0] : /* false */0;
  var start = rev ? k + 1 | 0 : 0;
  var len = rev ? /* None */0 : /* Some */[k];
  var partial_arg = Cmdliner_info.pos(rev, start, len);
  return (function (param, param$1, param$2) {
      return pos_list(partial_arg, param, param$1, param$2);
    });
}

function pos_right($staropt$star, k) {
  var rev = $staropt$star ? $staropt$star[0] : /* false */0;
  var start = rev ? 0 : k + 1 | 0;
  var len = rev ? /* Some */[k] : /* None */0;
  var partial_arg = Cmdliner_info.pos(rev, start, len);
  return (function (param, param$1, param$2) {
      return pos_list(partial_arg, param, param$1, param$2);
    });
}

function absent_error(args) {
  var make_req = function (a, acc) {
    var req_a = Cmdliner_info.arg_make_req(a);
    return Curry._2(Cmdliner_info.Args[/* add */3], req_a, acc);
  };
  return Curry._3(Cmdliner_info.Args[/* fold */13], make_req, args, Cmdliner_info.Args[/* empty */0]);
}

function value(a) {
  return a;
}

function err_arg_missing(args) {
  var e = Cmdliner_msg.err_arg_missing(Curry._1(Cmdliner_info.Args[/* choose */22], args));
  return /* Error */Block.__(1, [/* `Parse */[
              -796721133,
              e
            ]]);
}

function required(param) {
  var convert = param[1];
  var args = absent_error(param[0]);
  var convert$1 = function (ei, cl) {
    var e = Curry._2(convert, ei, cl);
    if (e.tag) {
      return e;
    } else {
      var match = e[0];
      if (match) {
        return /* Ok */Block.__(0, [match[0]]);
      } else {
        return err_arg_missing(args);
      }
    }
  };
  return /* tuple */[
          args,
          convert$1
        ];
}

function non_empty(param) {
  var convert = param[1];
  var args = absent_error(param[0]);
  var convert$1 = function (ei, cl) {
    var e = Curry._2(convert, ei, cl);
    if (e.tag) {
      return e;
    } else {
      var l = e[0];
      if (l) {
        return /* Ok */Block.__(0, [l]);
      } else {
        return err_arg_missing(args);
      }
    }
  };
  return /* tuple */[
          args,
          convert$1
        ];
}

function last(param) {
  var convert = param[1];
  var args = param[0];
  var convert$1 = function (ei, cl) {
    var e = Curry._2(convert, ei, cl);
    if (e.tag) {
      return e;
    } else {
      var l = e[0];
      if (l) {
        return /* Ok */Block.__(0, [List.hd(List.rev(l))]);
      } else {
        return err_arg_missing(args);
      }
    }
  };
  return /* tuple */[
          args,
          convert$1
        ];
}

var man_fmts = /* :: */[
  /* tuple */[
    "auto",
    /* Auto */726666127
  ],
  /* :: */[
    /* tuple */[
      "pager",
      /* Pager */-797271261
    ],
    /* :: */[
      /* tuple */[
        "groff",
        /* Groff */757208580
      ],
      /* :: */[
        /* tuple */[
          "plain",
          /* Plain */-675583510
        ],
        /* [] */0
      ]
    ]
  ]
];

var man_fmt_docv = "FMT";

var man_fmts_enum = Cmdliner_base.$$enum(man_fmts);

var man_fmts_alts = doc_alts_enum(/* None */0, man_fmts);

function man_fmts_doc(kind) {
  return Curry._2(Printf.sprintf(/* Format */[
                  /* String_literal */Block.__(11, [
                      "Show ",
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String_literal */Block.__(11, [
                              " in format $(docv). The value $(docv) must be ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* String_literal */Block.__(11, [
                                      ". With `auto',\n        the format is `pager` or `plain' whenever the $(b,TERM) env var is\n        `dumb' or undefined.",
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ])
                    ]),
                  "Show %s in format $(docv). The value $(docv) must be %s. With `auto',\n        the format is `pager` or `plain' whenever the $(b,TERM) env var is\n        `dumb' or undefined."
                ]), kind, man_fmts_alts);
}

var doc = man_fmts_doc("output");

var man_format = opt(/* None */0, man_fmts_enum, /* Pager */-797271261, Cmdliner_info.arg(/* None */0, /* Some */[man_fmt_docv], /* Some */[doc], /* None */0, /* :: */[
          "man-format",
          /* [] */0
        ]));

function stdopt_version(docs) {
  return flag(Cmdliner_info.arg(/* Some */[docs], /* None */0, /* Some */["Show version information."], /* None */0, /* :: */[
                  "version",
                  /* [] */0
                ]));
}

function stdopt_help(docs) {
  var doc = man_fmts_doc("this help");
  var partial_arg = Cmdliner_base.some(/* None */0, man_fmts_enum);
  var partial_arg$1 = /* Some */[/* Some */[/* Auto */726666127]];
  return (function (param) {
              return opt(partial_arg$1, partial_arg, /* None */0, param);
            })(Cmdliner_info.arg(/* Some */[docs], /* Some */[man_fmt_docv], /* Some */[doc], /* None */0, /* :: */[
                  "help",
                  /* [] */0
                ]));
}

var some = Cmdliner_base.some;

var env_var = Cmdliner_info.env;

var info = Cmdliner_info.arg;

var bool = Cmdliner_base.bool;

var $$char = Cmdliner_base.$$char;

var $$int = Cmdliner_base.$$int;

var nativeint = Cmdliner_base.nativeint;

var int32 = Cmdliner_base.int32;

var int64 = Cmdliner_base.int64;

var $$float = Cmdliner_base.$$float;

var string = Cmdliner_base.string;

var $$enum = Cmdliner_base.$$enum;

var file = Cmdliner_base.file;

var dir = Cmdliner_base.dir;

var non_dir_file = Cmdliner_base.non_dir_file;

var list = Cmdliner_base.list;

var array = Cmdliner_base.array;

var pair = Cmdliner_base.pair;

var t2 = Cmdliner_base.t2;

var t3 = Cmdliner_base.t3;

var t4 = Cmdliner_base.t4;

var doc_quote = Cmdliner_base.quote;

var doc_alts = Cmdliner_base.alts_str;

exports.conv = conv;
exports.pconv = pconv;
exports.conv_parser = conv_parser;
exports.conv_printer = conv_printer;
exports.conv_docv = conv_docv;
exports.parser_of_kind_of_string = parser_of_kind_of_string;
exports.some = some;
exports.env_var = env_var;
exports.info = info;
exports.$unknown = $unknown;
exports.flag = flag;
exports.flag_all = flag_all;
exports.vflag = vflag;
exports.vflag_all = vflag_all;
exports.opt = opt;
exports.opt_all = opt_all;
exports.pos = pos;
exports.pos_all = pos_all;
exports.pos_left = pos_left;
exports.pos_right = pos_right;
exports.value = value;
exports.required = required;
exports.non_empty = non_empty;
exports.last = last;
exports.man_format = man_format;
exports.stdopt_version = stdopt_version;
exports.stdopt_help = stdopt_help;
exports.bool = bool;
exports.$$char = $$char;
exports.$$int = $$int;
exports.nativeint = nativeint;
exports.int32 = int32;
exports.int64 = int64;
exports.$$float = $$float;
exports.string = string;
exports.$$enum = $$enum;
exports.file = file;
exports.dir = dir;
exports.non_dir_file = non_dir_file;
exports.list = list;
exports.array = array;
exports.pair = pair;
exports.t2 = t2;
exports.t3 = t3;
exports.t4 = t4;
exports.doc_quote = doc_quote;
exports.doc_alts = doc_alts;
exports.doc_alts_enum = doc_alts_enum;
/* all Not a pure module */
