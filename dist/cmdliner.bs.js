// Generated by BUCKLESCRIPT VERSION 2.2.2, PLEASE EDIT WITH CARE
'use strict';

var Sys = require("bs-platform/lib/js/sys.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_sys = require("bs-platform/lib/js/caml_sys.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Cmdliner_arg = require("./cmdliner_arg.bs.js");
var Cmdliner_msg = require("./cmdliner_msg.bs.js");
var Cmdliner_base = require("./cmdliner_base.bs.js");
var Cmdliner_info = require("./cmdliner_info.bs.js");
var Cmdliner_term = require("./cmdliner_term.bs.js");
var Cmdliner_trie = require("./cmdliner_trie.bs.js");
var Cmdliner_cline = require("./cmdliner_cline.bs.js");
var Cmdliner_docgen = require("./cmdliner_docgen.bs.js");
var Cmdliner_manpage = require("./cmdliner_manpage.bs.js");
var Cmdliner_suggest = require("./cmdliner_suggest.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function ret(param) {
  var v = param[1];
  return /* tuple */[
          param[0],
          (function (ei, cl) {
              var e = Curry._2(v, ei, cl);
              if (e.tag) {
                return e;
              } else {
                var err = e[0];
                if (err[0] >= 106380200) {
                  return /* Error */Block.__(1, [err]);
                } else {
                  return /* Ok */Block.__(0, [err[1]]);
                }
              }
            })
        ];
}

function term_result($staropt$star, param) {
  var v = param[1];
  var usage = $staropt$star ? $staropt$star[0] : /* false */0;
  return /* tuple */[
          param[0],
          (function (ei, cl) {
              var e = Curry._2(v, ei, cl);
              if (e.tag) {
                return e;
              } else {
                var ok = e[0];
                if (ok.tag) {
                  return /* Error */Block.__(1, [/* `Error */[
                              106380200,
                              /* tuple */[
                                usage,
                                ok[0][1]
                              ]
                            ]]);
                } else {
                  return ok;
                }
              }
            })
        ];
}

function cli_parse_result(param) {
  var v = param[1];
  return /* tuple */[
          param[0],
          (function (ei, cl) {
              var e = Curry._2(v, ei, cl);
              if (e.tag) {
                return e;
              } else {
                var ok = e[0];
                if (ok.tag) {
                  return /* Error */Block.__(1, [/* `Parse */[
                              -796721133,
                              ok[0][1]
                            ]]);
                } else {
                  return ok;
                }
              }
            })
        ];
}

var main_name_000 = Cmdliner_info.Args[/* empty */0];

function main_name_001(ei, _) {
  return /* Ok */Block.__(0, [Cmdliner_info.term_name(Cmdliner_info.eval_main(ei))]);
}

var main_name = /* tuple */[
  main_name_000,
  main_name_001
];

var choice_name = Cmdliner_info.term_name;

var choice_names_000 = Cmdliner_info.Args[/* empty */0];

function choice_names_001(ei, _) {
  return /* Ok */Block.__(0, [List.rev_map(choice_name, Cmdliner_info.eval_choices(ei))]);
}

var choice_names = /* tuple */[
  choice_names_000,
  choice_names_001
];

var default_error_exits_000 = Cmdliner_info.exit(/* None */0, /* Some */["on command line parsing errors."], /* None */0, 124);

var default_error_exits_001 = /* :: */[
  Cmdliner_info.exit(/* None */0, /* Some */["on unexpected internal errors (bugs)."], /* None */0, 125),
  /* [] */0
];

var default_error_exits = /* :: */[
  default_error_exits_000,
  default_error_exits_001
];

var default_exits_000 = Cmdliner_info.exit(/* None */0, /* Some */["on success."], /* None */0, 0);

var default_exits = /* :: */[
  default_exits_000,
  default_error_exits
];

var partial_arg = /* Some */[Cmdliner_info.Args[/* empty */0]];

function info(param, param$1, param$2, param$3, param$4, param$5, param$6, param$7, param$8) {
  return Cmdliner_info.term(partial_arg, param, param$1, param$2, param$3, param$4, param$5, param$6, param$7, param$8);
}

var name = Cmdliner_info.term_name;

function err_multi_cmd_def(name, param, param$1) {
  return Cmdliner_base.err_multi_def("command", name, Cmdliner_info.term_doc, param[0], param$1[0]);
}

function add_stdopts(ei) {
  var docs = Cmdliner_info.term_stdopts_docs(Cmdliner_info.eval_term(ei));
  var match = Cmdliner_info.term_version(Cmdliner_info.eval_main(ei));
  var match$1;
  if (match) {
    var vers = Cmdliner_arg.stdopt_version(docs);
    match$1 = /* tuple */[
      vers[0],
      /* Some */[vers]
    ];
  } else {
    match$1 = /* tuple */[
      Cmdliner_info.Args[/* empty */0],
      /* None */0
    ];
  }
  var help = Cmdliner_arg.stdopt_help(docs);
  var args = Curry._2(Cmdliner_info.Args[/* union */6], match$1[0], help[0]);
  var term = Cmdliner_info.term_add_args(Cmdliner_info.eval_term(ei), args);
  return /* tuple */[
          help,
          match$1[1],
          Cmdliner_info.eval_with_term(ei, term)
        ];
}

function run($$catch, ei, cl, f) {
  try {
    return Curry._2(f, ei, cl);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if ($$catch) {
      var bt = Printexc.get_raw_backtrace(/* () */0);
      return /* Error */Block.__(1, [/* `Exn */[
                  3458171,
                  /* tuple */[
                    exn,
                    bt
                  ]
                ]]);
    } else {
      throw exn;
    }
  }
}

function try_eval_stdopts($$catch, ei, cl, help, version) {
  var err = run($$catch, ei, cl, help[1]);
  if (err.tag) {
    return /* Some */[err];
  } else {
    var match = err[0];
    if (match) {
      return /* Some */[/* Error */Block.__(1, [/* `Std_help */[
                    -689884355,
                    match[0]
                  ]])];
    } else if (version) {
      var err$1 = run($$catch, ei, cl, version[0][1]);
      if (err$1.tag) {
        return /* Some */[err$1];
      } else if (err$1[0] !== 0) {
        return /* Some */[/* Error */Block.__(1, [/* Std_version */114449436])];
      } else {
        return /* None */0;
      }
    } else {
      return /* None */0;
    }
  }
}

function term_eval($$catch, ei, f, args) {
  var match = add_stdopts(ei);
  var ei$1 = match[2];
  var version = match[1];
  var help = match[0];
  var term_args = Cmdliner_info.term_args(Cmdliner_info.eval_term(ei$1));
  var match$1 = Cmdliner_cline.create(/* None */0, term_args, args);
  var res;
  if (match$1.tag) {
    var match$2 = match$1[0];
    var match$3 = try_eval_stdopts($$catch, ei$1, match$2[1], help, version);
    res = match$3 ? match$3[0] : /* Error */Block.__(1, [/* `Error */[
            106380200,
            /* tuple */[
              /* true */1,
              match$2[0]
            ]
          ]]);
  } else {
    var cl = match$1[0];
    var match$4 = try_eval_stdopts($$catch, ei$1, cl, help, version);
    res = match$4 ? match$4[0] : run($$catch, ei$1, cl, f);
  }
  return /* tuple */[
          ei$1,
          res
        ];
}

function do_help(help_ppf, err_ppf, ei, fmt, cmd) {
  var ei$1;
  if (cmd) {
    var cmd$1 = cmd[0];
    try {
      var is_cmd = function (t) {
        return +(Cmdliner_info.term_name(t) === cmd$1);
      };
      var cmd$2 = List.find(is_cmd, Cmdliner_info.eval_choices(ei));
      ei$1 = Cmdliner_info.eval_with_term(ei, cmd$2);
    }
    catch (exn){
      if (exn === Caml_builtin_exceptions.not_found) {
        ei$1 = Pervasives.invalid_arg("Term error, help requested for unknown command " + cmd$1);
      } else {
        throw exn;
      }
    }
  } else {
    ei$1 = Cmdliner_info.eval_with_term(ei, Cmdliner_info.eval_main(ei));
  }
  var match = add_stdopts(ei$1);
  return Cmdliner_docgen.pp_man(err_ppf, fmt, help_ppf, match[2]);
}

function do_result(help_ppf, err_ppf, ei, param) {
  if (param.tag) {
    var res = param[0];
    if (typeof res === "number") {
      Cmdliner_msg.pp_version(help_ppf, ei);
      return /* Version */-901574920;
    } else {
      var variant = res[0];
      if (variant !== -689884355) {
        if (variant >= 106380200) {
          if (variant >= 803495649) {
            var match = res[1];
            do_help(help_ppf, err_ppf, ei, match[0], match[1]);
            return /* Help */803495649;
          } else {
            var match$1 = res[1];
            var err = match$1[1];
            if (match$1[0]) {
              Cmdliner_msg.pp_err_usage(err_ppf, ei, err);
            } else {
              Cmdliner_msg.pp_err(err_ppf, ei, err);
            }
            return /* `Error */[
                    106380200,
                    /* Term */936571788
                  ];
          }
        } else if (variant >= 3458171) {
          var match$2 = res[1];
          Cmdliner_msg.pp_backtrace(err_ppf, ei, match$2[0], match$2[1]);
          return /* `Error */[
                  106380200,
                  /* Exn */3458171
                ];
        } else {
          Cmdliner_msg.pp_err_usage(err_ppf, ei, res[1]);
          return /* `Error */[
                  106380200,
                  /* Parse */-796721133
                ];
        }
      } else {
        Cmdliner_docgen.pp_man(err_ppf, res[1], help_ppf, ei);
        return /* Help */803495649;
      }
    }
  } else {
    return /* `Ok */[
            17724,
            param[0]
          ];
  }
}

function env_default(v) {
  try {
    return /* Some */[Caml_sys.caml_sys_getenv(v)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function remove_exec(argv) {
  try {
    return List.tl($$Array.to_list(argv));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return Pervasives.invalid_arg("argv array must have at least one element");
    } else {
      throw exn;
    }
  }
}

function $$eval($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, param) {
  var match = param[0];
  var help_ppf = $staropt$star ? $staropt$star[0] : Format.std_formatter;
  var err_ppf = $staropt$star$1 ? $staropt$star$1[0] : Format.err_formatter;
  var $$catch = $staropt$star$2 ? $staropt$star$2[0] : /* true */1;
  var env = $staropt$star$3 ? $staropt$star$3[0] : env_default;
  var argv = $staropt$star$4 ? $staropt$star$4[0] : Sys.argv;
  var term = Cmdliner_info.term_add_args(param[1], match[0]);
  var ei = Cmdliner_info.$$eval(term, term, /* [] */0, env);
  var args = remove_exec(argv);
  var match$1 = term_eval($$catch, ei, match[1], args);
  return do_result(help_ppf, err_ppf, match$1[0], match$1[1]);
}

function choose_term(main, choices, args) {
  if (args) {
    var maybe = args[0];
    if (maybe.length > 1 && Caml_string.get(maybe, 0) === /* "-" */45) {
      return /* Ok */Block.__(0, [/* tuple */[
                  main,
                  args
                ]]);
    } else {
      var add = function (acc, c) {
        var name = Cmdliner_info.term_name(c[0]);
        var match = Cmdliner_trie.add(acc, name, c);
        if (match[0] >= 3901504) {
          return match[1];
        } else {
          return Pervasives.invalid_arg(err_multi_cmd_def(name, c, match[1][0]));
        }
      };
      var index = List.fold_left(add, Cmdliner_trie.empty, choices);
      var match = Cmdliner_trie.find(index, maybe);
      if (typeof match === "number") {
        if (match >= -328798100) {
          var ambs = Cmdliner_trie.ambiguities(index, maybe);
          var ambs$1 = List.sort(Caml_obj.caml_compare, ambs);
          return /* Error */Block.__(1, [Cmdliner_base.err_ambiguous("command", maybe, ambs$1)]);
        } else {
          var all = Cmdliner_trie.ambiguities(index, "");
          var hints = Cmdliner_suggest.value(maybe, all);
          return /* Error */Block.__(1, [Cmdliner_base.err_unknown(/* Some */[hints], "command", maybe)]);
        }
      } else {
        return /* Ok */Block.__(0, [/* tuple */[
                    match[1],
                    args[1]
                  ]]);
      }
    }
  } else {
    return /* Ok */Block.__(0, [/* tuple */[
                main,
                /* [] */0
              ]]);
  }
}

function eval_choice($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, main, choices) {
  var help_ppf = $staropt$star ? $staropt$star[0] : Format.std_formatter;
  var err_ppf = $staropt$star$1 ? $staropt$star$1[0] : Format.err_formatter;
  var $$catch = $staropt$star$2 ? $staropt$star$2[0] : /* true */1;
  var env = $staropt$star$3 ? $staropt$star$3[0] : env_default;
  var argv = $staropt$star$4 ? $staropt$star$4[0] : Sys.argv;
  var to_term_f = function (param) {
    var match = param[0];
    return /* tuple */[
            Cmdliner_info.term_add_args(param[1], match[0]),
            match[1]
          ];
  };
  var choices_f = List.rev_map(to_term_f, choices);
  var main_f = to_term_f(main);
  var choices$1 = List.rev_map((function (prim) {
          return prim[0];
        }), choices_f);
  var main$1 = main_f[0];
  var match = choose_term(main_f, choices_f, remove_exec(argv));
  if (match.tag) {
    var ei = Cmdliner_info.$$eval(main$1, main$1, choices$1, env);
    Cmdliner_msg.pp_err_usage(err_ppf, ei, match[0]);
    return /* `Error */[
            106380200,
            /* Parse */-796721133
          ];
  } else {
    var match$1 = match[0];
    var match$2 = match$1[0];
    var ei$1 = Cmdliner_info.$$eval(match$2[0], main$1, choices$1, env);
    var match$3 = term_eval($$catch, ei$1, match$2[1], match$1[1]);
    return do_result(help_ppf, err_ppf, match$3[0], match$3[1]);
  }
}

function eval_peek_opts($staropt$star, $staropt$star$1, $staropt$star$2, param) {
  var version_opt = $staropt$star ? $staropt$star[0] : /* false */0;
  var env = $staropt$star$1 ? $staropt$star$1[0] : env_default;
  var argv = $staropt$star$2 ? $staropt$star$2[0] : Sys.argv;
  var version = version_opt ? /* Some */["dummy"] : /* None */0;
  var term = Cmdliner_info.term(/* Some */[param[0]], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, version, "dummy");
  var ei = Cmdliner_info.$$eval(term, term, /* [] */0, env);
  var ei$1 = ei;
  var f = param[1];
  var args = remove_exec(argv);
  var match = add_stdopts(ei$1);
  var ei$2 = match[2];
  var version$1 = match[1];
  var help = match[0];
  var term_args = Cmdliner_info.term_args(Cmdliner_info.eval_term(ei$2));
  var match$1 = Cmdliner_cline.create(/* Some */[/* true */1], term_args, args);
  var match$2;
  if (match$1.tag) {
    var match$3 = match$1[0];
    var match$4 = try_eval_stdopts(/* true */1, ei$2, match$3[1], help, version$1);
    match$2 = match$4 ? /* tuple */[
        /* None */0,
        match$4[0]
      ] : /* tuple */[
        /* None */0,
        /* Error */Block.__(1, [/* `Error */[
              106380200,
              /* tuple */[
                /* true */1,
                match$3[0]
              ]
            ]])
      ];
  } else {
    var cl = match$1[0];
    var ret = run(/* true */1, ei$2, cl, f);
    var v;
    v = ret.tag ? /* None */0 : /* Some */[ret[0]];
    var match$5 = try_eval_stdopts(/* true */1, ei$2, cl, help, version$1);
    match$2 = match$5 ? /* tuple */[
        v,
        match$5[0]
      ] : /* tuple */[
        v,
        ret
      ];
  }
  var ret$1 = match$2[1];
  var ret$2;
  if (ret$1.tag) {
    var match$6 = ret$1[0];
    if (typeof match$6 === "number") {
      ret$2 = /* Version */-901574920;
    } else {
      var variant = match$6[0];
      ret$2 = variant !== 3458171 ? (
          variant !== 106380200 ? (
              variant >= -796721132 ? /* Help */803495649 : /* `Error */[
                  106380200,
                  /* Parse */-796721133
                ]
            ) : /* `Error */[
              106380200,
              /* Term */936571788
            ]
        ) : /* `Error */[
          106380200,
          /* Exn */3458171
        ];
    }
  } else {
    ret$2 = /* `Ok */[
      17724,
      ret$1[0]
    ];
  }
  return /* tuple */[
          match$2[0],
          ret$2
        ];
}

function exit_status_of_result($staropt$star, param) {
  var term_err = $staropt$star ? $staropt$star[0] : 1;
  if (typeof param === "number") {
    return 0;
  } else if (param[0] >= 106380200) {
    var match = param[1];
    if (match !== 3458171) {
      if (match >= 936571788) {
        return term_err;
      } else {
        return 124;
      }
    } else {
      return 125;
    }
  } else {
    return 0;
  }
}

function exit_status_of_status_result(term_err, r) {
  if (typeof r === "number" || r[0] !== 17724) {
    return exit_status_of_result(term_err, r);
  } else {
    return r[1];
  }
}

function exit(term_err, r) {
  return Pervasives.exit(exit_status_of_result(term_err, r));
}

function exit_status(term_err, r) {
  return Pervasives.exit(exit_status_of_status_result(term_err, r));
}

var Manpage = [
  Cmdliner_manpage.$$escape,
  Cmdliner_manpage.s_name,
  Cmdliner_manpage.s_synopsis,
  Cmdliner_manpage.s_description,
  Cmdliner_manpage.s_commands,
  Cmdliner_manpage.s_arguments,
  Cmdliner_manpage.s_options,
  Cmdliner_manpage.s_common_options,
  Cmdliner_manpage.s_exit_status,
  Cmdliner_manpage.s_environment,
  Cmdliner_manpage.s_environment_intro,
  Cmdliner_manpage.s_files,
  Cmdliner_manpage.s_bugs,
  Cmdliner_manpage.s_examples,
  Cmdliner_manpage.s_authors,
  Cmdliner_manpage.s_see_also,
  Cmdliner_manpage.print
];

var Term = [
  Cmdliner_term.$$const,
  Cmdliner_term.$$const,
  Cmdliner_arg.man_format,
  Cmdliner_term.app,
  Cmdliner_term.app,
  ret,
  term_result,
  cli_parse_result,
  main_name,
  choice_names,
  Cmdliner_info.exit,
  default_exits,
  default_error_exits,
  Cmdliner_info.env,
  info,
  name,
  $$eval,
  eval_choice,
  eval_peek_opts,
  0,
  124,
  125,
  exit_status_of_result,
  exit_status_of_status_result,
  exit,
  exit_status
];

var Arg = [
  Cmdliner_arg.conv,
  Cmdliner_arg.pconv,
  Cmdliner_arg.conv_parser,
  Cmdliner_arg.conv_printer,
  Cmdliner_arg.conv_docv,
  Cmdliner_arg.parser_of_kind_of_string,
  Cmdliner_arg.some,
  Cmdliner_arg.env_var,
  Cmdliner_arg.info,
  Cmdliner_arg.$unknown,
  Cmdliner_arg.flag,
  Cmdliner_arg.flag_all,
  Cmdliner_arg.vflag,
  Cmdliner_arg.vflag_all,
  Cmdliner_arg.opt,
  Cmdliner_arg.opt_all,
  Cmdliner_arg.pos,
  Cmdliner_arg.pos_all,
  Cmdliner_arg.pos_left,
  Cmdliner_arg.pos_right,
  Cmdliner_arg.value,
  Cmdliner_arg.required,
  Cmdliner_arg.non_empty,
  Cmdliner_arg.last,
  Cmdliner_arg.man_format,
  Cmdliner_arg.bool,
  Cmdliner_arg.$$char,
  Cmdliner_arg.$$int,
  Cmdliner_arg.nativeint,
  Cmdliner_arg.int32,
  Cmdliner_arg.int64,
  Cmdliner_arg.$$float,
  Cmdliner_arg.string,
  Cmdliner_arg.$$enum,
  Cmdliner_arg.file,
  Cmdliner_arg.dir,
  Cmdliner_arg.non_dir_file,
  Cmdliner_arg.list,
  Cmdliner_arg.array,
  Cmdliner_arg.pair,
  Cmdliner_arg.t2,
  Cmdliner_arg.t3,
  Cmdliner_arg.t4,
  Cmdliner_arg.doc_quote,
  Cmdliner_arg.doc_alts,
  Cmdliner_arg.doc_alts_enum
];

exports.Manpage = Manpage;
exports.Term = Term;
exports.Arg = Arg;
/* default_error_exits Not a pure module */
